<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ankiç‰Œç»„é‡å»ºæµ‹è¯•</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .test-section {
            background: #f5f5f5;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
        }
        .test-button {
            background: #2196f3;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        .test-button:hover {
            background: #1976d2;
        }
        .test-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .success {
            background: #e8f5e8;
            color: #2e7d32;
            border: 1px solid #4caf50;
        }
        .error {
            background: #ffeaea;
            color: #c62828;
            border: 1px solid #f44336;
        }
        .info {
            background: #e3f2fd;
            color: #1565c0;
            border: 1px solid #2196f3;
        }
        .warning {
            background: #fff3e0;
            color: #ef6c00;
            border: 1px solid #ff9800;
        }
        .step {
            margin: 10px 0;
            padding: 10px;
            background: white;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .step-title {
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>ğŸ”„ Ankiç‰Œç»„é‡å»ºæµ‹è¯•</h1>
    
    <div class="test-section">
        <h2>æµ‹è¯•è¯´æ˜</h2>
        <p>æ­¤æµ‹è¯•ç”¨äºéªŒè¯å½“Ankiä¸­çš„ç‰Œç»„è¢«åˆ é™¤åï¼Œæ’ä»¶èƒ½å¦æ­£ç¡®é‡æ–°åˆ›å»ºç‰Œç»„å¹¶é‡ç½®åŒæ­¥çŠ¶æ€ã€‚</p>
        
        <div class="step">
            <div class="step-title">æµ‹è¯•æ­¥éª¤ï¼š</div>
            <ol>
                <li>ç¡®ä¿Ankiå·²å¯åŠ¨å¹¶å®‰è£…äº†AnkiConnectæ’ä»¶</li>
                <li>ç‚¹å‡»"æ£€æŸ¥è¿æ¥"ç¡®è®¤è¿æ¥æ­£å¸¸</li>
                <li>ç‚¹å‡»"åˆ›å»ºæµ‹è¯•æ•°æ®"æ·»åŠ ä¸€äº›æµ‹è¯•ç”Ÿè¯</li>
                <li>ç‚¹å‡»"åŒæ­¥åˆ°Anki"å°†ç”Ÿè¯åŒæ­¥åˆ°Anki</li>
                <li>åœ¨Ankiä¸­æ‰‹åŠ¨åˆ é™¤"è‹±è¯­ç”Ÿè¯"ç‰Œç»„</li>
                <li>å†æ¬¡ç‚¹å‡»"åŒæ­¥åˆ°Anki"ï¼Œè§‚å¯Ÿæ˜¯å¦é‡æ–°åˆ›å»ºç‰Œç»„</li>
            </ol>
        </div>
    </div>

    <div class="test-section">
        <h2>è¿æ¥æµ‹è¯•</h2>
        <button class="test-button" onclick="testConnection()">æ£€æŸ¥Ankiè¿æ¥</button>
        <button class="test-button" onclick="listDecks()">åˆ—å‡ºæ‰€æœ‰ç‰Œç»„</button>
        <div id="connectionResult" class="result"></div>
    </div>

    <div class="test-section">
        <h2>æµ‹è¯•æ•°æ®ç®¡ç†</h2>
        <button class="test-button" onclick="createTestData()">åˆ›å»ºæµ‹è¯•æ•°æ®</button>
        <button class="test-button" onclick="clearTestData()">æ¸…ç©ºæµ‹è¯•æ•°æ®</button>
        <button class="test-button" onclick="showVocabulary()">æ˜¾ç¤ºç”Ÿè¯è¡¨</button>
        <div id="dataResult" class="result"></div>
    </div>

    <div class="test-section">
        <h2>åŒæ­¥æµ‹è¯•</h2>
        <button class="test-button" onclick="syncToAnki()">åŒæ­¥åˆ°Anki</button>
        <button class="test-button" onclick="checkDeckExists()">æ£€æŸ¥ç‰Œç»„æ˜¯å¦å­˜åœ¨</button>
        <button class="test-button" onclick="resetSyncStatus()">é‡ç½®åŒæ­¥çŠ¶æ€</button>
        <div id="syncResult" class="result"></div>
    </div>

    <script src="anki-connect.js"></script>
    <script>
        let ankiConnect;
        
        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            ankiConnect = new AnkiConnect();
            showResult('connectionResult', 'é¡µé¢å·²åŠ è½½ï¼Œè¯·ç‚¹å‡»"æ£€æŸ¥Ankiè¿æ¥"å¼€å§‹æµ‹è¯•', 'info');
        });

        // æ˜¾ç¤ºç»“æœ
        function showResult(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            element.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            element.className = `result ${type}`;
        }

        // æµ‹è¯•è¿æ¥
        async function testConnection() {
            try {
                showResult('connectionResult', 'æ­£åœ¨æ£€æŸ¥è¿æ¥...', 'info');
                const isConnected = await ankiConnect.checkConnection();
                
                if (isConnected) {
                    showResult('connectionResult', 'âœ… Ankiè¿æ¥æˆåŠŸï¼', 'success');
                } else {
                    showResult('connectionResult', 'âŒ æ— æ³•è¿æ¥åˆ°Ankiï¼Œè¯·ç¡®ä¿Ankiå·²å¯åŠ¨å¹¶å®‰è£…äº†AnkiConnectæ’ä»¶', 'error');
                }
            } catch (error) {
                showResult('connectionResult', `âŒ è¿æ¥æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // åˆ—å‡ºç‰Œç»„
        async function listDecks() {
            try {
                showResult('connectionResult', 'æ­£åœ¨è·å–ç‰Œç»„åˆ—è¡¨...', 'info');
                const deckNames = await ankiConnect.getDeckNames();
                const hasTargetDeck = deckNames.includes('è‹±è¯­ç”Ÿè¯');
                
                showResult('connectionResult', 
                    `ğŸ“š æ‰¾åˆ° ${deckNames.length} ä¸ªç‰Œç»„:\n${deckNames.join(', ')}\n\n` +
                    `ç›®æ ‡ç‰Œç»„"è‹±è¯­ç”Ÿè¯": ${hasTargetDeck ? 'âœ… å­˜åœ¨' : 'âŒ ä¸å­˜åœ¨'}`, 
                    hasTargetDeck ? 'success' : 'warning'
                );
            } catch (error) {
                showResult('connectionResult', `âŒ è·å–ç‰Œç»„åˆ—è¡¨å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // åˆ›å»ºæµ‹è¯•æ•°æ®
        async function createTestData() {
            try {
                showResult('dataResult', 'æ­£åœ¨åˆ›å»ºæµ‹è¯•æ•°æ®...', 'info');
                
                const testWords = [
                    { word: 'hello', translation: 'ä½ å¥½', pronunciation: '/hÉ™ËˆloÊŠ/', addedAt: new Date().toISOString() },
                    { word: 'world', translation: 'ä¸–ç•Œ', pronunciation: '/wÉœËrld/', addedAt: new Date().toISOString() },
                    { word: 'test', translation: 'æµ‹è¯•', pronunciation: '/test/', addedAt: new Date().toISOString() },
                    { word: 'anki', translation: 'æš—è®°', pronunciation: '/ËˆÃ¦nki/', addedAt: new Date().toISOString() },
                    { word: 'sync', translation: 'åŒæ­¥', pronunciation: '/sÉªÅ‹k/', addedAt: new Date().toISOString() }
                ];

                // è·å–ç°æœ‰ç”Ÿè¯è¡¨
                const result = await new Promise(resolve => {
                    chrome.storage.sync.get(['vocabulary'], resolve);
                });
                
                const vocabulary = result.vocabulary || [];
                
                // æ·»åŠ æµ‹è¯•æ•°æ®ï¼ˆé¿å…é‡å¤ï¼‰
                let addedCount = 0;
                for (const testWord of testWords) {
                    const exists = vocabulary.some(item => item.word === testWord.word);
                    if (!exists) {
                        vocabulary.push(testWord);
                        addedCount++;
                    }
                }

                // ä¿å­˜åˆ°å­˜å‚¨
                await new Promise(resolve => {
                    chrome.storage.sync.set({ vocabulary }, resolve);
                });

                showResult('dataResult', 
                    `âœ… æµ‹è¯•æ•°æ®åˆ›å»ºå®Œæˆï¼\næ·»åŠ äº† ${addedCount} ä¸ªæ–°ç”Ÿè¯\næ€»è®¡ ${vocabulary.length} ä¸ªç”Ÿè¯`, 
                    'success'
                );
            } catch (error) {
                showResult('dataResult', `âŒ åˆ›å»ºæµ‹è¯•æ•°æ®å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ¸…ç©ºæµ‹è¯•æ•°æ®
        async function clearTestData() {
            try {
                if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æµ‹è¯•æ•°æ®å—ï¼Ÿ')) {
                    return;
                }
                
                showResult('dataResult', 'æ­£åœ¨æ¸…ç©ºæµ‹è¯•æ•°æ®...', 'info');
                
                await new Promise(resolve => {
                    chrome.storage.sync.set({ vocabulary: [] }, resolve);
                });

                showResult('dataResult', 'âœ… æµ‹è¯•æ•°æ®å·²æ¸…ç©º', 'success');
            } catch (error) {
                showResult('dataResult', `âŒ æ¸…ç©ºæµ‹è¯•æ•°æ®å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ˜¾ç¤ºç”Ÿè¯è¡¨
        async function showVocabulary() {
            try {
                showResult('dataResult', 'æ­£åœ¨è·å–ç”Ÿè¯è¡¨...', 'info');
                
                const result = await new Promise(resolve => {
                    chrome.storage.sync.get(['vocabulary'], resolve);
                });
                
                const vocabulary = result.vocabulary || [];
                
                if (vocabulary.length === 0) {
                    showResult('dataResult', 'ğŸ“ ç”Ÿè¯è¡¨ä¸ºç©º', 'info');
                    return;
                }

                const syncedCount = vocabulary.filter(item => item.ankiSynced).length;
                const unsyncedCount = vocabulary.length - syncedCount;
                
                let message = `ğŸ“ ç”Ÿè¯è¡¨ (${vocabulary.length} ä¸ªç”Ÿè¯):\n`;
                message += `å·²åŒæ­¥: ${syncedCount} ä¸ª | æœªåŒæ­¥: ${unsyncedCount} ä¸ª\n\n`;
                
                vocabulary.forEach((item, index) => {
                    const status = item.ankiSynced ? 'âœ…' : 'â³';
                    message += `${index + 1}. ${status} ${item.word} - ${item.translation}\n`;
                });

                showResult('dataResult', message, 'info');
            } catch (error) {
                showResult('dataResult', `âŒ è·å–ç”Ÿè¯è¡¨å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // åŒæ­¥åˆ°Anki
        async function syncToAnki() {
            try {
                showResult('syncResult', 'ğŸ”„ å¼€å§‹åŒæ­¥åˆ°Anki...', 'info');
                
                // æ£€æŸ¥è¿æ¥
                const isConnected = await ankiConnect.checkConnection();
                if (!isConnected) {
                    throw new Error('æ— æ³•è¿æ¥åˆ°Anki');
                }

                // è·å–ç”Ÿè¯è¡¨
                const result = await new Promise(resolve => {
                    chrome.storage.sync.get(['vocabulary'], resolve);
                });
                const vocabulary = result.vocabulary || [];
                
                if (vocabulary.length === 0) {
                    showResult('syncResult', 'âŒ ç”Ÿè¯è¡¨ä¸ºç©ºï¼Œæ— æ³•åŒæ­¥', 'error');
                    return;
                }

                // æ£€æŸ¥ç‰Œç»„æ˜¯å¦å­˜åœ¨
                const deckName = 'è‹±è¯­ç”Ÿè¯';
                const deckNames = await ankiConnect.getDeckNames();
                let deckRecreated = false;
                
                if (!deckNames.includes(deckName)) {
                    showResult('syncResult', `ğŸ”„ ç‰Œç»„ "${deckName}" ä¸å­˜åœ¨ï¼Œæ­£åœ¨åˆ›å»º...`, 'warning');
                    await ankiConnect.createDeck(deckName);
                    deckRecreated = true;
                    
                    // é‡ç½®æ‰€æœ‰ç”Ÿè¯çš„åŒæ­¥çŠ¶æ€
                    let needsReset = false;
                    for (let item of vocabulary) {
                        if (item.ankiSynced) {
                            item.ankiSynced = false;
                            delete item.ankiNoteId;
                            delete item.syncedAt;
                            needsReset = true;
                        }
                    }
                    
                    if (needsReset) {
                        await new Promise(resolve => {
                            chrome.storage.sync.set({ vocabulary }, resolve);
                        });
                        showResult('syncResult', `âœ… å·²é‡æ–°åˆ›å»ºç‰Œç»„å¹¶é‡ç½®åŒæ­¥çŠ¶æ€`, 'success');
                    }
                }

                // ç­›é€‰æœªåŒæ­¥çš„å•è¯
                const unsyncedWords = vocabulary.filter(item => !item.ankiSynced);
                
                if (unsyncedWords.length === 0) {
                    showResult('syncResult', 'âœ… æ‰€æœ‰ç”Ÿè¯å·²åŒæ­¥åˆ°Anki', 'success');
                    return;
                }

                showResult('syncResult', `ğŸ”„ æ­£åœ¨åŒæ­¥ ${unsyncedWords.length} ä¸ªç”Ÿè¯...`, 'info');

                // æ‰¹é‡æ·»åŠ åˆ°Anki
                const noteIds = await ankiConnect.addNotes(unsyncedWords, deckName, (progress) => {
                    showResult('syncResult', `ğŸ”„ åŒæ­¥è¿›åº¦: ${progress}/${unsyncedWords.length}`, 'info');
                });
                
                // æ›´æ–°åŒæ­¥çŠ¶æ€
                let successCount = 0;
                let skippedCount = 0;
                
                for (let i = 0; i < unsyncedWords.length; i++) {
                    const wordIndex = vocabulary.findIndex(item => 
                        item.word === unsyncedWords[i].word && !item.ankiSynced
                    );
                    
                    if (wordIndex !== -1) {
                        if (noteIds[i] !== null) {
                            vocabulary[wordIndex].ankiSynced = true;
                            vocabulary[wordIndex].ankiNoteId = noteIds[i];
                            vocabulary[wordIndex].syncedAt = new Date().toISOString();
                            successCount++;
                        } else {
                            vocabulary[wordIndex].ankiSynced = true;
                            vocabulary[wordIndex].ankiNoteId = 'skipped';
                            vocabulary[wordIndex].syncedAt = new Date().toISOString();
                            skippedCount++;
                        }
                    }
                }

                // ä¿å­˜æ›´æ–°åçš„ç”Ÿè¯è¡¨
                await new Promise(resolve => {
                    chrome.storage.sync.set({ vocabulary }, resolve);
                });
                
                // æ˜¾ç¤ºåŒæ­¥ç»“æœ
                let message = `âœ… åŒæ­¥å®Œæˆï¼\n`;
                if (deckRecreated) {
                    message += `ğŸ”„ é‡æ–°åˆ›å»ºäº†ç‰Œç»„ "${deckName}"\n`;
                }
                message += `æ–°å¢: ${successCount} ä¸ª\n`;
                if (skippedCount > 0) {
                    message += `è·³è¿‡: ${skippedCount} ä¸ª (å·²å­˜åœ¨)\n`;
                }
                message += `æ€»è®¡: ${vocabulary.length} ä¸ªç”Ÿè¯`;
                
                showResult('syncResult', message, 'success');

            } catch (error) {
                showResult('syncResult', `âŒ åŒæ­¥å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ£€æŸ¥ç‰Œç»„æ˜¯å¦å­˜åœ¨
        async function checkDeckExists() {
            try {
                showResult('syncResult', 'æ­£åœ¨æ£€æŸ¥ç‰Œç»„...', 'info');
                
                const deckNames = await ankiConnect.getDeckNames();
                const deckName = 'è‹±è¯­ç”Ÿè¯';
                const exists = deckNames.includes(deckName);
                
                showResult('syncResult', 
                    `ğŸ“š ç‰Œç»„æ£€æŸ¥ç»“æœ:\n` +
                    `ç›®æ ‡ç‰Œç»„: "${deckName}"\n` +
                    `çŠ¶æ€: ${exists ? 'âœ… å­˜åœ¨' : 'âŒ ä¸å­˜åœ¨'}\n` +
                    `æ‰€æœ‰ç‰Œç»„: ${deckNames.join(', ')}`, 
                    exists ? 'success' : 'warning'
                );
            } catch (error) {
                showResult('syncResult', `âŒ æ£€æŸ¥ç‰Œç»„å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // é‡ç½®åŒæ­¥çŠ¶æ€
        async function resetSyncStatus() {
            try {
                if (!confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰ç”Ÿè¯çš„åŒæ­¥çŠ¶æ€å—ï¼Ÿè¿™å°†ä½¿æ‰€æœ‰ç”Ÿè¯é‡æ–°åŒæ­¥åˆ°Ankiã€‚')) {
                    return;
                }
                
                showResult('syncResult', 'æ­£åœ¨é‡ç½®åŒæ­¥çŠ¶æ€...', 'info');
                
                const result = await new Promise(resolve => {
                    chrome.storage.sync.get(['vocabulary'], resolve);
                });
                
                const vocabulary = result.vocabulary || [];
                let resetCount = 0;
                
                for (let item of vocabulary) {
                    if (item.ankiSynced) {
                        item.ankiSynced = false;
                        delete item.ankiNoteId;
                        delete item.syncedAt;
                        resetCount++;
                    }
                }

                await new Promise(resolve => {
                    chrome.storage.sync.set({ vocabulary }, resolve);
                });

                showResult('syncResult', `âœ… å·²é‡ç½® ${resetCount} ä¸ªç”Ÿè¯çš„åŒæ­¥çŠ¶æ€`, 'success');
            } catch (error) {
                showResult('syncResult', `âŒ é‡ç½®åŒæ­¥çŠ¶æ€å¤±è´¥: ${error.message}`, 'error');
            }
        }
    </script>
</body>
</html>